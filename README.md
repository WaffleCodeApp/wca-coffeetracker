# Coffee Rewards Tracker

A web application for tracking coffee consumption with a gamified rewards system. Users can log their daily coffee intake, set goals, track progress, and earn rewards. Features monthly SaaS subscriptions with payment processing. Designed specifically for programmers who prefer desktop computers and keyboard shortcuts over mobile apps.

## Overview

This repository contains a complete infrastructure-as-code solution generated by restack.dev. The project was created through natural language conversation with an AI assistant, which translated high-level requirements into deployable infrastructure configurations.

### What This Repository Contains

- **Infrastructure Configuration**: Complete AWS infrastructure definitions in `infrastructure.json`
- **Service Implementations**: Sample, hello-world-level code for each service component
- **Environment Configurations**: Multi-environment setup for different SDLC stages
- **Deployment Ready**: Fully configured for deployment to AWS with automated CI/CD pipelines

## Architecture

This project consists of the following components:

### frontend

**Type**: Static Frontend (React SPA, TypeScript)
**Description**: React/Vue SPA optimized for desktop use with keyboard shortcuts, user dashboard for coffee logging, goal tracking, and subscription management. Includes authentication flows and payment forms.
**Integration**: AWS Cognito authentication

Each service includes its own README with detailed implementation instructions.

### api

**Type**: Serverless Function (AWS Lambda)
**Description**: Main API handling user management, coffee entry CRUD operations, goal tracking, progress calculations, and rewards logic. Integrates with DynamoDB for data persistence and Cognito for authentication.
**Integration**: HTTP API trigger

Each service includes its own README with detailed implementation instructions.

### payments

**Type**: Serverless Function (AWS Lambda)
**Description**: Dedicated payment processing function handling subscription payments, webhook processing from payment providers (Stripe), and subscription status updates. Uses queue-based processing for reliability.
**Integration**: HTTP API with queue integration

Each service includes its own README with detailed implementation instructions.

## Repository Structure

```
Coffee Rewards Tracker/
â”œâ”€â”€ README.md                    # This file - project overview
â”œâ”€â”€ infrastructure.json          # Complete infrastructure configuration
â”œâ”€â”€ frontend/               # Static Frontend (React/Vue/Angular SPA)
â”œâ”€â”€ api/               # Serverless Function (AWS Lambda)
â”œâ”€â”€ payments/               # Serverless Function (AWS Lambda)
```

## Environments

This project is configured with a **main** environment that is ready for deployment:

- **Main Environment**: Currently deployed and configured to deploy from the `main` branch
- **Auto-deployment**: Changes pushed to the main branch will automatically trigger deployments
- **Production-ready**: The main environment is configured for production workloads

### Adding Additional Environments

You can create additional environments (such as development, staging, etc.) through the restack.dev platform:

1. **Use the Chat Interface**: Ask the AI assistant to create new environments
2. **Environment Types**: Common environments include:
   - **Development**: For feature development and testing
   - **Staging**: For pre-production validation
   - **Preview**: For pull request testing
3. **Custom Configuration**: Each environment can have different:
   - Domain names and SSL certificates
   - Authentication configurations
   - Database settings and scaling parameters
   - Branch deployment strategies

### Current Environment Status

- âœ… **Main Environment**: Active and ready for deployment
- ðŸ”„ **Additional Environments**: Available to create via chat interface

## Getting Started

### For Developers

1. **Explore Service Folders**: Each service has its own directory with sample implementations
2. **Read Service READMEs**: Detailed instructions for each component
3. **Understand Infrastructure**: Review `infrastructure.json` to understand the complete setup
4. **Customize Services**: Replace hello-world implementations with your business logic

### For Deployment

This repository is pre-configured for deployment to the restack.dev platform:

1. **Production Deployment**: Create pull request to `main` branch for production
2. **Infrastructure Updates**: Modify `infrastructure.json` to change AWS resources
3. **Service Updates**: Update service code in respective folders

## Service Details

### frontend
This static frontend (react/vue/angular spa) component.

- **Deployment**: S3 + CloudFront CDN
- **Build Process**: Automated CI/CD pipeline
- **Authentication**: AWS Cognito integration

### api
This serverless function (aws lambda) component.

- **Runtime**: AWS Lambda serverless function
- **Trigger**: HTTP API
- **Scaling**: Automatic scaling based on requests

### payments
This serverless function (aws lambda) component.

- **Runtime**: AWS Lambda serverless function
- **Trigger**: HTTP API with queue integration
- **Scaling**: Automatic scaling based on requests


## Repository Ownership

### Taking Ownership

You have the option to take full ownership of this repository:

- **GitHub Repository**: Transfer ownership to your GitHub organization
- **AWS Account**: Request ownership of the AWS account where your solution is deployed
- **Full Control**: Complete autonomy over infrastructure and deployments

### Current State

- Repository is managed by the restack.dev platform
- AWS resources are deployed in the platform's organization
- CI/CD pipelines are automatically configured and maintained

## Infrastructure Configuration Reference

The `infrastructure.json` file uses restack.dev's Infrastructure as Low Code (IaLC) format. This section explains the structure and options available.

### What is restack.dev?

restack.dev is an AI-powered infrastructure-as-code platform that helps you generate production-grade infrastructure in seconds through natural language chat interactions. Key features include:

- **AI-Powered Infrastructure Generation**: Chat with AI to build infrastructure configurations from natural language descriptions
- **GitHub Integration**: Automatic deployment from GitHub repositories to AWS accounts
- **Production-Grade Infrastructure**: Generates enterprise-ready AWS infrastructure with security, monitoring, and scaling built-in
- **Sample Code Provision**: Provides boilerplate code for frontend and backend stacks
- **Full Ownership Options**: Take ownership of both GitHub repositories and AWS accounts when ready

### Environment Name to Branch Mapping

**Important**: The environment name directly maps to the GitHub repository branch that will be deployed from:

- Environment name `"dev"` â†’ deploys from the `dev` branch
- Environment name `"main"` â†’ deploys from the `main` branch  
- Environment name `"staging"` â†’ deploys from the `staging` branch
- Environment name `"production"` â†’ deploys from the `production` branch

**Deployment Flow**:
1. Each environment name creates a dedicated AWS account for deployment
2. The platform automatically deploys from the corresponding GitHub branch
3. For example: if you create an environment called `"dev"`, the platform will:
   - Create a dedicated AWS account for the `dev` environment
   - Deploy all services from the `dev` branch of your GitHub repositories
   - Apply the `dev` environment's configuration settings

This ensures complete isolation between environments and automatic branch-to-environment mapping.

### Infrastructure Configuration Structure

```json
{
  "version": "string",
  "environments": {
    "environment_name": {
      "resources": {
        "envFeatures": { /* environment features */ },
        "services": {
          "service_name": { /* service configuration */ }
        }
      }
    }
  }
}
```

### Environment Features (envFeatures)

Environment features define shared infrastructure components that apply to all services within an environment.

#### VPC Configuration

AWS VPC with private subnets for secure serverless deployments.

**What it does**:
- Creates AWS VPC with private and public subnets
- **Serverless Lambda Functions**: Deploys Lambda functions in VPC private subnets for enhanced security
- **VPC Endpoints**: Enables access to DynamoDB, S3, and ECR through VPC endpoints (no internet routing required)
- **Auto-enabled with Container Services**: AI automatically enables VPC when containerized backend services are present (required for security)

#### Authentication Configuration

AWS Cognito User Pool for user authentication and authorization.

**What it does**:
- Creates AWS Cognito User Pool for user authentication
- **Google Integration**: Can be configured for Google OAuth authentication
- **Self-Signup Control**: `allowAdminCreateUserOnly: true` prevents users from self-registering with email/password
- **Frontend Integration**: Each static frontend service gets its own Cognito User Pool client
- **OIDC Integration**: Supports third-party authentication providers on the frontend service level
- **Hosted Auth Pages**: Available if you take ownership of the AWS account
- **Recommended Approach**: Use Amplify UI components in your frontend with the User Pool client

#### API Gateway Options

**HTTP API V2** (AI's default choice):
- AWS API Gateway HTTP API V2 - lean and simple with easy stage deployment
- **AI Default Choice**: AI automatically chooses this API Gateway when the generated stack requires an API
- **Lean Architecture**: Simpler and more cost-effective than REST API V1

**REST API V1** (Manual choice):
- AWS API Gateway REST API V1 - best choice for API key management
- **API Key Management**: Best choice if you need API keys handled by the API Gateway
- **Manual Configuration**: Must be manually enabled in the config file (AI doesn't auto-enable this)

Both are auto-enabled with containerized backend services.

#### Custom Domain Configuration

- **Auto-generated Domains**: restack.dev automatically generates domain names for each project (e.g., `httpapi.myproject.app.restack.dev`)
- **Bring Your Own Domain**: Use your own domain instead of the auto-generated one
- **SSL Certificate**: Requires an SSL certificate to be created (possible when you take ownership of the AWS account)
- **Subdomain Structure**: API, auth, and other services deploy to subdomains of your project domain

### Service Types

Services are defined within the `services` object and can be one of five types: CONTAINER, CDN, FUNCTION, CUSTOM, or DB.

#### Container Service (CONTAINER)
Deploys containerized applications using ECS with optional auto-scaling.

#### CDN Service (STATIC_FRONTEND)
Deploys static frontend applications with CloudFront CDN.

#### Function Service (FUNCTION)
Deploys serverless functions using AWS Lambda.

#### Database Service (DB)
Deploys relational databases using RDS or Aurora.

#### Custom Service (CUSTOM)
Deploys custom CloudFormation stacks.

### AI Generation Guidelines

When generating infrastructure configurations for restack.dev:

1. **Start with basic structure**: Always include version and at least one environment
2. **Typical starting point**: Most users start with a single "main" environment that deploys from the "main" branch
3. **Environment naming**: Use standard environment names that match your GitHub branches
4. **Choose appropriate services**: Match service types to application needs
5. **Set sensible defaults**: Use platform defaults unless specific requirements exist
6. **Consider security**: Enable VPC, auth, and WAF for production environments
7. **Auto-enablement rules**: 
   - **VPC + API Gateway**: Automatically enabled when containerized backend services are present
   - **HTTP API V2**: AI's default choice for API Gateway (lean and simple)
   - **REST API V1**: Manual choice if API key management is needed
8. **Plan for scaling**: Use auto-scaling for container services, appropriate instance sizes
9. **Environment separation**: Different configurations for dev/staging/production
10. **Git integration**: Repository and branch are automatically mapped by environment name
11. **Monitoring**: Enable alarms and logging for production workloads

### AWS Region and Availability Zones

- **AWS Region**: The AWS region is set when you create the environment in the restack.dev UI (default: us-east-1)
- **Availability Zones**: Default to "a" and "b" zones (e.g., us-east-1a, us-east-1b)
- **Zone Availability**: Some AWS regions don't have a "b" availability zone. If you change the default region, verify that both availability zones exist in your chosen region
- **Custom Zones**: You can override the default zones if needed for specific requirements

### Complete Example

```json
{
  "version": "1",
  "environments": {
    "production": {
      "resources": {
        "envFeatures": {
          "vpc": {
            "enabled": true,
            "primaryPrivateCidr": "10.0.1.0/24",
            "secondaryPrivateCidr": "10.0.2.0/24",
            "availabilityZone1": "us-east-1a",
            "availabilityZone2": "us-east-1b"
          },
          "auth": {
            "enabled": true,
            "mfaRequired": true,
            "alertsEnabled": true
          },
          "customDomain": {
            "deploymentDomainName": "api.example.com",
            "certArn": "arn:aws:acm:us-east-1:123456789012:certificate/..."
          },
          "httpApiV2": {
            "enabled": true,
            "subdomain": "api"
          },
          "defaultAlarmsEnabled": true,
          "defaultDatabaseRetention": 30,
          "defaultLogsRetention": 90
        },
        "services": {
          "frontend": {
            "stackType": "STATIC_FRONTEND",
            "webHostname": "www",
            "gitRepositoryId": "my-org/frontend",
            "auth": {
              "enabled": true,
              "googleEnabled": true
            }
          },
          "api": {
            "stackType": "FUNCTION",
            "functionTrigger": "HTTP_API_TRIGGER",
            "gitRepositoryId": "my-org/api",
            "buildEnvVarsJson": "{\"NODE_ENV\":\"production\"}"
          },
          "database": {
            "stackType": "DB",
            "allocatedStorage": 100,
            "dbType": "RDS",
            "instanceClass": "db.t3.small",
            "multiAz": true
          }
        }
      }
    }
  }
}
```

## Support and Documentation

- **Service Documentation**: Each service folder contains detailed README files
- **Infrastructure Reference**: `infrastructure.json` contains complete configuration
- **Platform Documentation**: Visit the restack.dev platform for additional resources

## Next Steps

1. **Review Infrastructure**: Understand the complete setup in `infrastructure.json`
2. **Explore Services**: Check each service folder for implementation details
3. **Customize Code**: Replace sample implementations with your business logic
4. **Deploy Changes**: Use the automated CI/CD pipeline for deployments
5. **Take Ownership**: When ready, request repository and AWS account ownership

---

*This repository was generated by restack.dev - an AI-powered infrastructure-as-code platform that transforms natural language requirements into deployable AWS infrastructure.*
