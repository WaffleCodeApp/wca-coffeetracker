# Cursor Rules for Coffee Rewards Tracker

## Project Overview

A web application for tracking coffee consumption with a gamified rewards system. Users can log their daily coffee intake, set goals, track progress, and earn rewards. Features monthly SaaS subscriptions with payment processing. Designed specifically for programmers who prefer desktop interfaces and keyboard shortcuts over mobile apps.

This is an enterprise-grade, production-ready infrastructure solution generated by the ReStack Infrastructure CICD Platform. The project uses Infrastructure as Code (IaC) principles with automated CI/CD pipelines for secure, scalable AWS deployments.

## Architecture Components

This project includes the following service types:

### frontend
- **Type**: STATIC_FRONTEND
- **Description**: React SPA optimized for desktop use with keyboard shortcuts, user dashboard for coffee logging, goal tracking, and subscription management. Includes authentication flows and payment forms.
- **Integration**: Cognito Authentication

### api
- **Type**: FUNCTION
- **Description**: Main API handling user management, coffee entry CRUD operations, goal tracking, progress calculations, and rewards logic. Integrates with DynamoDB for data persistence and Cognito for authentication.
- **Integration**: HTTP API Trigger

### payments
- **Type**: FUNCTION
- **Description**: Dedicated payment processing function handling subscription payments, webhook processing from payment providers (Stripe), and subscription status updates. Uses queue-based processing for reliability.
- **Integration**: HTTP API + Queue


## Security Guidelines

### Credential Management
- **CRITICAL**: Never store sensitive data in environment variables
- **CRITICAL**: All credentials must be stored in AWS Secrets Manager
- Use boto3 (Python) or AWS SDK v3 (Node.js/TypeScript) to retrieve secrets
- Service-specific secrets available via $SERVICE_SECRET_ARN environment variable
- Deployment-wide secrets available via $DEPLOYMENT_SECRET_ARN environment variable

### Service Discovery
- Use AWS Systems Manager (SSM) Parameter Store for service discovery
- Never hardcode hostnames, ARNs, or other infrastructure references
- Common SSM paths:
  - ECS Service ALB: /{deploymentId}/ecs/{stackName}/albDnsName
  - Database Secret: /{deploymentId}/db/{dbName}/secretName
  - Frontend Hostname: /{deploymentId}/cdn/{stackName}/public_hostname
  - Auth Client ID: /{deploymentId}/cdn/{stackName}/auth_user_pool_client_id

### Authentication & Authorization
- Validate ID tokens received from API Gateway or frontend
- Implement proper token expiration and refresh logic
- Use IAM roles and policies for service-to-service communication
- Never log or expose sensitive authentication data

### Monitoring & Alerting
- Use $ALERTS_TOPIC_ARN environment variable for sending alerts
- SNS topic delivers to email by default, easily extensible to Slack/other services
- Implement proper error handling and logging
- Use structured logging for better observability


## Static Frontend Guidelines

### Build Configuration
- Frontend is built via CodePipeline and deployed to S3 + CloudFront
- Build process uses the buildspec.yml file in the service directory
- Static files are served via CloudFront CDN for global performance

### Authentication Integration
- If authentication is enabled, Cognito UserPool Client ID is available in SSM
- SSM path: /{deploymentId}/cdn/{stackName}/auth_user_pool_client_id
- Frontend hostname available at: /{deploymentId}/cdn/{stackName}/public_hostname
- Implement proper token refresh and logout flows

### API Integration
- Use SigV4 signing for authenticated API requests
- Pass ID tokens to backend services for user identification
- Implement proper error handling for API failures

## Lambda Function Guidelines

### Function Configuration
- Functions are deployed as Docker containers on AWS Lambda
- Custom CloudFormation templates define the function infrastructure
- Build process uses buildspec.yml for container image creation

### Trigger Types
- **HTTP API Trigger**: Direct API Gateway integration
- **Queue Trigger**: SQS-based asynchronous processing
- **HTTP API + Queue**: Combined synchronous and asynchronous processing

### Service Discovery
- Store function ARNs, SQS URLs, or SNS topics in SSM for other services to discover
- Use SSM paths like: /{deploymentId}/cfn/{stackName}/functionArn
- Enable cross-service communication through well-defined interfaces (AWS CloudFormation exports and AWS SSM parameters)


## Environment Configuration

### Multi-Environment Support
- Main environment is currently configured and active
- Additional environments (dev, staging, etc.) can be created via AI chat interface
- Each environment has isolated AWS resources and configurations

### Authentication Environment
- Cognito UserPool manages user authentication
- Google OAuth integration available
- MFA can be configured per environment
- Frontend receives Cognito tokens for API authentication





### Infrastructure as Code
- All infrastructure defined in infrastructure.json
- Changes to infrastructure trigger automatic CloudFormation updates
- Version-controlled infrastructure ensures consistency across environments


## Code Structure Guidelines

### Repository Organization
```
project-root/
├── infrastructure.json          # Complete infrastructure configuration
├── .cursorrules                # This file - development guidelines
├── README.md                   # Project documentation
├── frontend/                  # STATIC_FRONTEND service
├── api/                  # FUNCTION service
├── payments/                  # FUNCTION service
```

### Service Structure
Each service directory should contain:
- **README.md**: Service-specific documentation and setup instructions
- **Source Code**: Implementation following the service type guidelines
- **Configuration**: Service-specific configuration files
- **Build Files**: Dockerfile (containers), buildspec.yml (functions), etc.

### Development Workflow
1. **Local Development**: Use local development tools while connecting to deployed infrastructure
2. **Testing**: Test against actual AWS services in development environment
3. **Deployment**: Push to configured branch triggers automatic deployment
4. **Monitoring**: Use CloudWatch and configured alerting for operational insights

## Development Best Practices

### Code Quality
- Write secure, production-ready code from the start
- Implement proper error handling and logging
- Use TypeScript for Node.js projects, type hints for Python
- Follow the principle of least privilege for all AWS permissions

### Testing Strategy
- Test against real AWS services in development environment
- Implement integration tests for cross-service communication
- Use infrastructure testing for CloudFormation templates
- Monitor and alert on key application metrics

### Deployment Strategy
- Use feature branches for development
- Deploy to development environment for testing
- Use pull requests for production deployments
- Monitor deployment pipelines and rollback if necessary

### Performance Optimization
- Implement proper caching strategies
- Use CDN for static content delivery
- Optimize database queries and connection pooling
- Configure auto-scaling based on actual usage patterns

## Platform Integration

### AI-Powered Development
- Use the WCA platform's AI chat interface for infrastructure modifications
- Request new environments or service configurations through natural language
- Get deployment status and monitoring insights via the platform

### Repository Management
- Infrastructure changes are version-controlled in infrastructure.json
- Service implementations are in respective service directories
- CI/CD pipelines automatically deploy changes based on branch configuration

### Ownership Options
- Repository can be transferred to your GitHub organization
- AWS account ownership can be requested for full control
- Platform provides ongoing support and monitoring capabilities

---

*These rules were generated by the WCA Infrastructure CICD Platform to ensure secure, scalable, and maintainable code development for your specific infrastructure configuration.*
